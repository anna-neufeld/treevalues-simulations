is.Collagen+
is.Matrigel+
is.NHDFs, data=dat))
summary(modVolC)
summary(modVolC)$coefficients[9:12,1]
summary(lm(mouseResids~row+coldist+
+           is.gelMA+
+           pct.gelMA+
+           is.Collagen+
+           is.Matrigel+
+           is.NHDFs, data=dat))
setwd("~/Dropbox/Tree Values Paper/Code Reviewer Response/more permutations/")
library(tidyverse)
filename <- "permutations_3-32-2022.csv"
res <- read.csv(filename, header=FALSE, sep=" ")
names(res) <- c("beta","XORlev", "seed", "depth", "samp_sig", "true_sig",
"lengths01", "lengths1", "pvals1", "CIs1_low","CIs1_high",
"lengths02", "lengths2", "pvals2","CIs2_low","CIs2_high",
"lengths03", "lengths3", "pvals3","CIs3_low","CIs3_high",
"lengths04", "lengths4", "pvals4","CIs4_low","CIs4_high",
"lengths05", "lengths5", "pvals5","CIs5_low","CIs5_high",
"lengths06", "lengths6", "pvals6","CIs6_low","CIs6_high")
res <- res %>% mutate(width1 = CIs1_high-CIs1_low,
width2 = CIs2_high-CIs2_low,
width3 = CIs3_high-CIs3_low,
width4 = CIs4_high-CIs4_low,
width5 = CIs5_high-CIs5_low,
width6 = CIs6_high-CIs6_low)
res <- res %>% filter(XORlev==1)
#### ITS NOT FOR SIBS so I CANT DO THAT DETECTION DEFINITION
#### I THINK this conditional power plot makes the most sense
p1 <- ggplot(data=res)+geom_smooth( aes(x=true_sig, y=as.numeric(pvals1 < 0.05), col="1"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=true_sig, y=as.numeric(pvals2 < 0.05), col="2"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth( aes(x=true_sig, y=as.numeric(pvals3 < 0.05), col="3"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth( aes(x=true_sig, y=as.numeric(pvals4 < 0.05), col="4"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth( aes(x=true_sig, y=as.numeric(pvals5 < 0.05), col="5"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth( aes(x=true_sig, y=as.numeric(pvals6 < 0.05), col="6"), se=F, method="glm",  method.args = list(family = "binomial"))+
xlim(0,20)+
ylab("Estimated Power")+xlab("True Difference in Means")+labs(col="Size of Q")+
theme_bw()#+facet_grid(vars(XORlev))
head(res)
#### ITS NOT FOR SIBS so I CANT DO THAT DETECTION DEFINITION
#### I THINK this conditional power plot makes the most sense
p1 <- ggplot(data=res)+geom_smooth( aes(x=true_sig, y=as.numeric(pvals1 < 0.05), col=expression(p[branch])), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth(aes(x=true_sig, y=as.numeric(pvals2 < 0.05), col="2"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals3 < 0.05), col="3"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals4 < 0.05), col="4"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals5 < 0.05), col="5"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth( aes(x=true_sig, y=as.numeric(pvals6 < 0.05), col= expression(p[reg])), se=F, method="glm",  method.args = list(family = "binomial"))+
xlim(0,20)+
ylab("Estimated Power")+xlab("True Difference in Means")+labs(col="Size of Q")+
theme_bw()#+facet_grid(vars(XORlev))
p1
#### ITS NOT FOR SIBS so I CANT DO THAT DETECTION DEFINITION
#### I THINK this conditional power plot makes the most sense
p1 <- ggplot(data=res)+geom_smooth( aes(x=true_sig, y=as.numeric(pvals1 < 0.05), col="(22)"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth(aes(x=true_sig, y=as.numeric(pvals2 < 0.05), col="2"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals3 < 0.05), col="3"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals4 < 0.05), col="4"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals5 < 0.05), col="5"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth( aes(x=true_sig, y=as.numeric(pvals6 < 0.05), col= "(15)"), se=F, method="glm",  method.args = list(family = "binomial"))+
xlim(0,20)+
ylab("Estimated Power")+xlab("True Difference in Means")+labs(col="Size of Q")+
theme_bw()#+facet_grid(vars(XORlev))
p2 <- ggplot(data=res)+geom_smooth( aes(x=true_sig, y=width1, col="(22)"), se=F)+
#geom_smooth(aes(x=true_sig, y=width2, col="2"), se=F)+
#geom_smooth( aes(x=true_sig, y=width3, col="3"), se=F)+
#geom_smooth( aes(x=true_sig, y=width4, col="4"), se=F)+
#geom_smooth( aes(x=true_sig, y=width5, col="5"), se=F)+
geom_smooth( aes(x=true_sig, y=width6, col="(15)"), se=F)+labs(col="Size of Q")
p1+p2
#### ITS NOT FOR SIBS so I CANT DO THAT DETECTION DEFINITION
#### I THINK this conditional power plot makes the most sense
p1 <- ggplot(data=res)+geom_smooth( aes(x=true_sig, y=as.numeric(pvals1 < 0.05), col="(22)"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth(aes(x=true_sig, y=as.numeric(pvals2 < 0.05), col="2"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals3 < 0.05), col="3"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals4 < 0.05), col="4"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals5 < 0.05), col="5"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth( aes(x=true_sig, y=as.numeric(pvals6 < 0.05), col= "(15)"), se=F, method="glm",  method.args = list(family = "binomial"))+
xlim(0,20)+
ylab("Estimated Power")+xlab("True Difference in Means")+labs(col="Size of Q")+
theme_bw()#+facet_grid(vars(XORlev))
p1
p2 <- ggplot(data=res)+geom_smooth( aes(x=true_sig, y=width1, col="(22)"), se=F)+
#geom_smooth(aes(x=true_sig, y=width2, col="2"), se=F)+
#geom_smooth( aes(x=true_sig, y=width3, col="3"), se=F)+
#geom_smooth( aes(x=true_sig, y=width4, col="4"), se=F)+
#geom_smooth( aes(x=true_sig, y=width5, col="5"), se=F)+
geom_smooth( aes(x=true_sig, y=width6, col="(15)"), se=F)+labs(col="Size of Q")
p2
consRes <- res %>% group_by(beta, XORlev) %>% summarize(width1=median(width1),
width2 = median(width2),
width3 = median(width3),
width4 = median(width4),
width5 = median(width5),
width6 = median(width6))
p2 <- ggplot(data=consRes)+geom_smooth( aes(x=beta, y=width1, col="1"), se=F)+
geom_smooth(aes(x=beta, y=width2, col="2"), se=F)+
geom_smooth( aes(x=beta, y=width3, col="3"), se=F)+
geom_smooth( aes(x=beta, y=width4, col="4"), se=F)+
geom_smooth( aes(x=beta, y=width5, col="5"), se=F)+
geom_smooth( aes(x=beta, y=width6, col="6"), se=F)+
xlab("b")+ylab("Median CI Width") + theme_bw()+labs(col="Size of Q") #+facet_grid(vars(XORlev))
p2 <- ggplot(data=consRes)+geom_smooth( aes(x=beta, y=width1, col="(23)"), se=F)+
#geom_smooth(aes(x=beta, y=width2, col="2"), se=F)+
#geom_smooth( aes(x=beta, y=width3, col="3"), se=F)+
#geom_smooth( aes(x=beta, y=width4, col="4"), se=F)+
#geom_smooth( aes(x=beta, y=width5, col="5"), se=F)+
geom_smooth( aes(x=beta, y=width6, col="(17)"), se=F)+
xlab("b")+ylab("Median CI Width") + theme_bw()+labs(col="Size of Q") #+facet_grid(vars(XORlev))
p3 <- p1 + xlim(7.5,15)
p2 <- ggplot(data=consRes)+geom_smooth( aes(x=beta, y=width1, col="(23)"), se=F)+
#geom_smooth(aes(x=beta, y=width2, col="2"), se=F)+
#geom_smooth( aes(x=beta, y=width3, col="3"), se=F)+
#geom_smooth( aes(x=beta, y=width4, col="4"), se=F)+
#geom_smooth( aes(x=beta, y=width5, col="5"), se=F)+
geom_smooth( aes(x=beta, y=width6, col="(17)"), se=F)+
xlab("b")+ylab("Median CI Width") + theme_bw()+labs(col="Method") #+facet_grid(vars(XORlev))
p3 <- p1 + xlim(7.5,15)
library(patchwork)
p1+p3+p2+plot_layout(guides="collect")
#### ITS NOT FOR SIBS so I CANT DO THAT DETECTION DEFINITION
#### I THINK this conditional power plot makes the most sense
p1 <- ggplot(data=res)+geom_smooth( aes(x=true_sig, y=as.numeric(pvals1 < 0.05), col="Identity permutation only"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth(aes(x=true_sig, y=as.numeric(pvals2 < 0.05), col="2"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals3 < 0.05), col="3"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals4 < 0.05), col="4"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals5 < 0.05), col="5"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth( aes(x=true_sig, y=as.numeric(pvals6 < 0.05), col= "Full conditioning set"), se=F, method="glm",  method.args = list(family = "binomial"))+
xlim(0,20)+
ylab("Estimated Power")+xlab("True Difference in Means")+labs(col="Conditioning set")+
theme_bw()#+facet_grid(vars(XORlev))
consRes <- res %>% group_by(beta, XORlev) %>% summarize(width1=median(width1),
width2 = median(width2),
width3 = median(width3),
width4 = median(width4),
width5 = median(width5),
width6 = median(width6))
p2 <- ggplot(data=consRes)+geom_smooth( aes(x=beta, y=width1, col="Identity permutation only"), se=F)+
#geom_smooth(aes(x=beta, y=width2, col="2"), se=F)+
#geom_smooth( aes(x=beta, y=width3, col="3"), se=F)+
#geom_smooth( aes(x=beta, y=width4, col="4"), se=F)+
#geom_smooth( aes(x=beta, y=width5, col="5"), se=F)+
geom_smooth( aes(x=beta, y=width6, col="Full Conditioning Set"), se=F)+
xlab("b")+ylab("Median CI Width") + theme_bw()+labs(col="Method") #+facet_grid(vars(XORlev))
p3 <- p1 + xlim(7.5,15)
library(patchwork)
p1+p3+p2+plot_layout(guides="collect")
#### ITS NOT FOR SIBS so I CANT DO THAT DETECTION DEFINITION
#### I THINK this conditional power plot makes the most sense
p1 <- ggplot(data=res)+geom_smooth( aes(x=true_sig, y=as.numeric(pvals1 < 0.05), col="Identity permutation only"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth(aes(x=true_sig, y=as.numeric(pvals2 < 0.05), col="2"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals3 < 0.05), col="3"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals4 < 0.05), col="4"), se=F, method="glm",  method.args = list(family = "binomial"))+
#geom_smooth( aes(x=true_sig, y=as.numeric(pvals5 < 0.05), col="5"), se=F, method="glm",  method.args = list(family = "binomial"))+
geom_smooth( aes(x=true_sig, y=as.numeric(pvals6 < 0.05), col= "Full conditioning set"), se=F, method="glm",  method.args = list(family = "binomial"))+
xlim(0,20)+
ylab("Estimated Power")+xlab("True Difference in Means")+labs(col="Method")+
theme_bw()#+facet_grid(vars(XORlev))
consRes <- res %>% group_by(beta, XORlev) %>% summarize(width1=median(width1),
width2 = median(width2),
width3 = median(width3),
width4 = median(width4),
width5 = median(width5),
width6 = median(width6))
p2 <- ggplot(data=consRes)+geom_smooth( aes(x=beta, y=width1, col="Identity permutation only"), se=F)+
#geom_smooth(aes(x=beta, y=width2, col="2"), se=F)+
#geom_smooth( aes(x=beta, y=width3, col="3"), se=F)+
#geom_smooth( aes(x=beta, y=width4, col="4"), se=F)+
#geom_smooth( aes(x=beta, y=width5, col="5"), se=F)+
geom_smooth( aes(x=beta, y=width6, col="Full conditioning Set"), se=F)+
xlab("b")+ylab("Median CI Width") + theme_bw()+labs(col="Method") #+facet_grid(vars(XORlev))
p3 <- p1 + xlim(7.5,15)
library(patchwork)
p1+p3+p2+plot_layout(guides="collect")
p2 <- ggplot(data=consRes)+geom_smooth( aes(x=beta, y=width1, col="Identity permutation only"), se=F)+
#geom_smooth(aes(x=beta, y=width2, col="2"), se=F)+
#geom_smooth( aes(x=beta, y=width3, col="3"), se=F)+
#geom_smooth( aes(x=beta, y=width4, col="4"), se=F)+
#geom_smooth( aes(x=beta, y=width5, col="5"), se=F)+
geom_smooth( aes(x=beta, y=width6, col="Full conditioning set"), se=F)+
xlab("b")+ylab("Median CI Width") + theme_bw()+labs(col="Method") #+facet_grid(vars(XORlev))
p3 <- p1 + xlim(7.5,15)
library(patchwork)
p1+p3+p2+plot_layout(guides="collect")
ggsave("~/Dropbox/Tree Values Paper/JMLR Reviewer Responses/permutation_res.png", width=9, height=3)
ggsave("~/Dropbox/Tree Values Paper/JMLR_submit_v3/permutation_res.png", width=9, height=3)
ggsave("~/Dropbox/Tree Values Paper/JMLR_submit_v3/Figures/permutation_res.png", width=9, height=3)
### The code that makes this data is in "rand_power_indices.R". The simulations were run from the file "run_power_rand.R".
library(tidyverse)
library(gridExtra)
library(patchwork)
#naivezcol <- "#7CAE00"
#sampsplitcol <- "#00BFC4"
treevalcol <- "#F8766D"
sigmaSSEcol <- "navy"
sigmaConscol <- "darkgray"
setwd("~/Dropbox/Tree Values Paper/Code Reviewer Response/unknown variance/")
res<- read.csv("Full_Rand_Comps_4-8-2022.csv", header=FALSE,sep=" ")
names(res)<- c("cp", "seed", "depth", "beta", "method", "pval",
"pval_cons", "pval_SSE", "pval_med", "pval_mad", "truesig","n1", "n2", "samplesig", "bestRand", "whichSplit","XORlev", "best", "NA")
ggplot(data=res %>% filter(!is.na(depth), !is.na(XORlev)))+
geom_smooth(aes(x=abs(truesig), y=as.numeric(pval < 0.05), col="known"), lwd=2, se=F, method="glm", method.args=list(family="binomial"))+
geom_smooth(aes(x=abs(truesig), y=as.numeric(pval_cons < 0.05), col="cons"), se=F, method="glm", method.args=list(family="binomial"))+
geom_smooth(aes(x=abs(truesig), y=as.numeric(pval_SSE < 0.05), col="SSE"), se=F, method="glm", method.args=list(family="binomial"))+
theme_bw()+facet_grid(rows=vars(XORlev), col=vars(depth))
#res <- res %>% filter(!is.na(bestRand))
# res2 <- res %>% group_by(cp, method, seed,XORlev,beta, depth, pval,
#                          pval_cons, pval_SSE, pval_med, pval_mad, truesig, n1, n2, samplesig) %>%
#   summarize(bestRand = max(bestRand),whichSplit = which.max(bestRand))
res2 <- res
res2$whichSplit <- as.numeric(res2$whichSplit)
res2 <- res2 %>% mutate(whichSplitLev = ifelse(whichSplit >=3,3,whichSplit))
res2 <- res2 %>% mutate(truesplitlev = ifelse(whichSplit >=3, 3, whichSplit))
res2 <- res2 %>%
mutate(
correct = as.numeric(bestRand > 0.75),
correctreject = as.numeric(bestRand > 0.75 & pval < 0.05),
correctreject_cons = as.numeric(bestRand > 0.75 & pval_cons < 0.05),
correctreject_SSE = as.numeric(bestRand > 0.75 & pval_SSE < 0.05),
correctreject_med = as.numeric(bestRand > 0.75 & pval_med < 0.05)
)
#### HOW MANY TRUE TREES WERE MADE FOR EACH BETA. It's just 500, which I set. Didn't want it hardcoded though.
ntree <-  NROW((res %>% filter(depth==1,method=="condition",XORlev==2,beta==10)))
groupRes <- res2 %>% group_by(method, XORlev, truesplitlev, beta) %>% summarize(
numcorrect = sum(correct),
numcorrectreject = sum(correctreject),
numcorrectreject_cons = sum(correctreject_cons),
numcorrectreject_SSE = sum(correctreject_SSE),
numcorrectreject_med = sum(correctreject_med)
) %>%
mutate(propCorrect = ifelse(truesplitlev < 3, numcorrect/ntree, numcorrect/(2*ntree)),
propCorrectReject= ifelse(truesplitlev < 3, numcorrectreject/ntree, numcorrectreject/(2*ntree)),
propCorrectReject= ifelse(truesplitlev < 3, numcorrectreject/ntree, numcorrectreject/(2*ntree)),
propCorrectReject_cons = ifelse(truesplitlev < 3, numcorrectreject_cons/ntree, numcorrectreject_cons/(2*ntree)),
propCorrectReject_SSE = ifelse(truesplitlev < 3, numcorrectreject_SSE/ntree, numcorrectreject_SSE/(2*ntree)),
propCorrectReject_med = ifelse(truesplitlev < 3, numcorrectreject_med/ntree, numcorrectreject_med/(2*ntree))
) %>%
mutate(
beta=as.numeric(beta),
propCorrect=as.numeric(propCorrect),
propCorrectReject=as.numeric(propCorrectReject),
propCorrectReject_cons = as.numeric(propCorrectReject_cons)
) %>%
mutate(truesplitlev2 = paste("Level ", truesplitlev))
groupRes$XORlev2 <- paste0("a=", groupRes$XORlev)
##### Estimated vs Not estimated. POwer ONly
groupRes$level2 <- paste("Level", groupRes$truesplitlev)
p3 <- ggplot(data=groupRes %>% filter(XORlev==1, !is.na(truesplitlev), !is.na(XORlev2))) +
geom_smooth(aes(x=beta,y=propCorrect, col="zknown", lty="Proportion Detected"),
se=F,method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=beta,y=propCorrectReject, col="zknown", lty="Proportion Detected and Rejected"),
se=F,method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=beta,y=propCorrectReject_cons, col="cons",lty="Proportion Detected and Rejected"),
se=F,method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=beta,y=propCorrectReject_SSE, col="SSE"),
se=F,method="glm",  method.args = list(family = "binomial"), lty=3)+
ylab("Proportion of True Splits Detected and Rejected")+xlab("b")+
facet_grid(cols  =
vars(level2)) + theme_bw()+
scale_color_manual(labels=c(expression(hat(sigma)[cons]), expression(hat(sigma)[SSE]),
expression(sigma)),
values=c(sigmaConscol, sigmaSSEcol, treevalcol))+
labs(col="", linetype="")+
guides(linetype="none")
p3
head(groupRes$level2)
library(tidyverse)
library(gridExtra)
#naivezcol <- "#7CAE00"
#sampsplitcol <- "#00BFC4"
treevalcol <- "#F8766D"
sigmaSSEcol <- "navy"
sigmaConscol <- "darkgray"
setwd("~/Dropbox/Tree Values Paper/Code Reviewer Response/unknown variance/")
nullRes <- read.csv("null_res_var_est.csv", sep=" ", header=FALSE)
names(nullRes) <- c("cp", "seed", "method", "type", "depth", "pval", "n1", "n2", "sampsig", "NA")
nullRes <- nullRes %>% filter(method != "mad")
nullRes$method = ordered(nullRes$method, levels=c("cons",
"SSE", "known", "med_yc"))
nullRes$level = paste("Level", nullRes$depth)
ggplot(data=nullRes %>% filter(method != 'med_yc'), aes(sample=pval, col=method))+
geom_qq(distribution="qunif", alpha=0.8)+
facet_grid(cols=vars(level))+
geom_abline(slope=1, intercept=0)+coord_fixed()+theme_bw()+
xlab("Unif(0,1) Quantiles")+ylab("Empirical Quantiles")+
labs(col="")+
scale_color_manual(labels=c(expression(hat(sigma)[cons]), expression(hat(sigma)[SSE]),
expression(sigma)),
values=c(sigmaConscol, sigmaSSEcol, treevalcol))#+
ggplot(data=nullRes %>% filter(method != 'med_yc'), aes(sample=pval, col=method))+
geom_qq(distribution="qunif", alpha=0.8)+
facet_grid(cols=vars(level))+
geom_abline(slope=1, intercept=0)+coord_fixed()+theme_bw()+
xlab("Unif(0,1) Quantiles")+ylab("Empirical Quantiles")+
labs(col="")+
scale_color_manual(labels=c(expression(hat(sigma)[cons]), expression(hat(sigma)[SSE]),
expression(paste("True", sigma))),
values=c(sigmaConscol, sigmaSSEcol, treevalcol))#+
ggplot(data=nullRes %>% filter(method != 'med_yc'), aes(sample=pval, col=method))+
geom_qq(distribution="qunif", alpha=0.8)+
facet_grid(cols=vars(level))+
geom_abline(slope=1, intercept=0)+coord_fixed()+theme_bw()+
xlab("Unif(0,1) Quantiles")+ylab("Empirical Quantiles")+
labs(col="")+
scale_color_manual(labels=c(expression(hat(sigma)[cons]), expression(hat(sigma)[SSE]),
expression(paste("True ", sigma))),
values=c(sigmaConscol, sigmaSSEcol, treevalcol))#+
ggplot(data=nullRes %>% filter(method != 'med_yc'), aes(sample=pval, col=method))+
geom_qq(distribution="qunif", alpha=0.8)+
facet_grid(cols=vars(level))+
geom_abline(slope=1, intercept=0)+coord_fixed()+theme_bw()+
xlab("Unif(0,1) Quantiles")+ylab("Empirical Quantiles")+
labs(col="")+
scale_color_manual(labels=c(expression(hat(sigma)[cons]), expression(hat(sigma)[SSE]),
expression(paste("True ", sigma))),
values=c(sigmaConscol, sigmaSSEcol, treevalcol))+
theme(legend.text.align = 0)
#theme(strip.text = element_text(size = 20))
ggsave("~/Dropbox/Tree Values Paper/JMLR Reviewer Responses/global_null_fig.png",
width=8, height=4)
ggsave("~/Dropbox/Tree Values Paper/JMLR_submit_v3/Figures/global_null_fig_est.png",
width=8, height=4)
### The code that makes this data is in "rand_power_indices.R". The simulations were run from the file "run_power_rand.R".
library(tidyverse)
library(gridExtra)
library(patchwork)
#naivezcol <- "#7CAE00"
#sampsplitcol <- "#00BFC4"
treevalcol <- "#F8766D"
sigmaSSEcol <- "navy"
sigmaConscol <- "darkgray"
setwd("~/Dropbox/Tree Values Paper/Code Reviewer Response/unknown variance/")
res<- read.csv("Full_Rand_Comps_4-8-2022.csv", header=FALSE,sep=" ")
names(res)<- c("cp", "seed", "depth", "beta", "method", "pval",
"pval_cons", "pval_SSE", "pval_med", "pval_mad", "truesig","n1", "n2", "samplesig", "bestRand", "whichSplit","XORlev", "best", "NA")
ggplot(data=res %>% filter(!is.na(depth), !is.na(XORlev)))+
geom_smooth(aes(x=abs(truesig), y=as.numeric(pval < 0.05), col="known"), lwd=2, se=F, method="glm", method.args=list(family="binomial"))+
geom_smooth(aes(x=abs(truesig), y=as.numeric(pval_cons < 0.05), col="cons"), se=F, method="glm", method.args=list(family="binomial"))+
geom_smooth(aes(x=abs(truesig), y=as.numeric(pval_SSE < 0.05), col="SSE"), se=F, method="glm", method.args=list(family="binomial"))+
theme_bw()+facet_grid(rows=vars(XORlev), col=vars(depth))
#res <- res %>% filter(!is.na(bestRand))
# res2 <- res %>% group_by(cp, method, seed,XORlev,beta, depth, pval,
#                          pval_cons, pval_SSE, pval_med, pval_mad, truesig, n1, n2, samplesig) %>%
#   summarize(bestRand = max(bestRand),whichSplit = which.max(bestRand))
res2 <- res
res2$whichSplit <- as.numeric(res2$whichSplit)
res2 <- res2 %>% mutate(whichSplitLev = ifelse(whichSplit >=3,3,whichSplit))
res2 <- res2 %>% mutate(truesplitlev = ifelse(whichSplit >=3, 3, whichSplit))
res2 <- res2 %>%
mutate(
correct = as.numeric(bestRand > 0.75),
correctreject = as.numeric(bestRand > 0.75 & pval < 0.05),
correctreject_cons = as.numeric(bestRand > 0.75 & pval_cons < 0.05),
correctreject_SSE = as.numeric(bestRand > 0.75 & pval_SSE < 0.05),
correctreject_med = as.numeric(bestRand > 0.75 & pval_med < 0.05)
)
#### HOW MANY TRUE TREES WERE MADE FOR EACH BETA. It's just 500, which I set. Didn't want it hardcoded though.
ntree <-  NROW((res %>% filter(depth==1,method=="condition",XORlev==2,beta==10)))
groupRes <- res2 %>% group_by(method, XORlev, truesplitlev, beta) %>% summarize(
numcorrect = sum(correct),
numcorrectreject = sum(correctreject),
numcorrectreject_cons = sum(correctreject_cons),
numcorrectreject_SSE = sum(correctreject_SSE),
numcorrectreject_med = sum(correctreject_med)
) %>%
mutate(propCorrect = ifelse(truesplitlev < 3, numcorrect/ntree, numcorrect/(2*ntree)),
propCorrectReject= ifelse(truesplitlev < 3, numcorrectreject/ntree, numcorrectreject/(2*ntree)),
propCorrectReject= ifelse(truesplitlev < 3, numcorrectreject/ntree, numcorrectreject/(2*ntree)),
propCorrectReject_cons = ifelse(truesplitlev < 3, numcorrectreject_cons/ntree, numcorrectreject_cons/(2*ntree)),
propCorrectReject_SSE = ifelse(truesplitlev < 3, numcorrectreject_SSE/ntree, numcorrectreject_SSE/(2*ntree)),
propCorrectReject_med = ifelse(truesplitlev < 3, numcorrectreject_med/ntree, numcorrectreject_med/(2*ntree))
) %>%
mutate(
beta=as.numeric(beta),
propCorrect=as.numeric(propCorrect),
propCorrectReject=as.numeric(propCorrectReject),
propCorrectReject_cons = as.numeric(propCorrectReject_cons)
) %>%
mutate(truesplitlev2 = paste("Level ", truesplitlev))
groupRes$XORlev2 <- paste0("a=", groupRes$XORlev)
##### Estimated vs Not estimated. POwer ONly
groupRes$level2 <- paste("Level", groupRes$truesplitlev)
p3 <- ggplot(data=groupRes %>% filter(XORlev==1, !is.na(truesplitlev), !is.na(XORlev2))) +
geom_smooth(aes(x=beta,y=propCorrect, col="zknown", lty="Proportion Detected"),
se=F,method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=beta,y=propCorrectReject, col="zknown", lty="Proportion Detected and Rejected"),
se=F,method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=beta,y=propCorrectReject_cons, col="cons",lty="Proportion Detected and Rejected"),
se=F,method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=beta,y=propCorrectReject_SSE, col="SSE"),
se=F,method="glm",  method.args = list(family = "binomial"), lty=3)+
ylab("Proportion of True Splits Detected and Rejected")+xlab("b")+
facet_grid(cols  =
vars(level2)) + theme_bw()+
scale_color_manual(labels=c(expression(hat(sigma)[cons]), expression(hat(sigma)[SSE]),
paste("True ", expression(sigma))),
values=c(sigmaConscol, sigmaSSEcol, treevalcol))+
theme(legend.text.align = 0)+
labs(col="", linetype="")+
guides(linetype="none")
p3
p3 <- ggplot(data=groupRes %>% filter(XORlev==1, !is.na(truesplitlev), !is.na(XORlev2))) +
geom_smooth(aes(x=beta,y=propCorrect, col="zknown", lty="Proportion Detected"),
se=F,method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=beta,y=propCorrectReject, col="zknown", lty="Proportion Detected and Rejected"),
se=F,method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=beta,y=propCorrectReject_cons, col="cons",lty="Proportion Detected and Rejected"),
se=F,method="glm",  method.args = list(family = "binomial"))+
geom_smooth(aes(x=beta,y=propCorrectReject_SSE, col="SSE"),
se=F,method="glm",  method.args = list(family = "binomial"), lty=3)+
ylab("Proportion of True Splits Detected and Rejected")+xlab("b")+
facet_grid(cols  =
vars(level2)) + theme_bw()+
scale_color_manual(labels=c(expression(hat(sigma)[cons]), expression(hat(sigma)[SSE]),
expression(paste("True ", sigma))),
values=c(sigmaConscol, sigmaSSEcol, treevalcol))+
theme(legend.text.align = 0)+
labs(col="", linetype="")+
guides(linetype="none")
p3
ggsave("~/Dropbox/Tree Values Paper/JMLR Reviewer Responses/power.png",
width=8, height=4)
ggsave("~/Dropbox/Tree Values Paper/JMLR_submit_v3/Figures/power.png",
width=8, height=4)
setwd("~/Dropbox/Tree Values Paper/Code : Other for Creating All Figures/")
library(rpart)
library(partykit)
library(treevalues)
## This code comes firectly from the VisTree Github Page
covariates <-blsdata %>% dplyr::select(hunger, disinhibition, resteating, rrvfood, liking, wanting, kcal24h0)
covariates<-data.frame(scale(covariates))
p2<-partykit::ctree(kcal24h0~hunger+ disinhibition+resteating+rrvfood+ liking+wanting, data = covariates, control = ctree_control(mincriterion = 0.95))
p4<-rpart(kcal24h0~., model = TRUE, data = covariates,control = rpart.control(cp = 0.0185, maxcompete = 0, maxsurrogate = 0))
p4$frame$yval[1] <- 0 ## Avoid printing 10^{-18} when I for sure know that it is supposed to be a 0
# This makes a throwaway rpart object with the same size as the fitted CTree tree p2.
# It is a hacky way to manually turn our CTree into an rpart object.
temp <-rpart(kcal24h0~., model = TRUE, data = covariates,control = rpart.control(maxdepth=3,cp=0.03001, maxcompete = 0, maxsurrogate = 0))
temp <- inferenceFrame(temp)
temp$frame$pval <- c(NA, "< 0.001", "< 0.001", "< 0.001", "= 0.016", "= 0.016", "<0.01")
## Now manually (using p2 from above as a guide)-- turn this rpart into the CTree!!
## Make the splits say the correct thing for labeling splits!!
temp$frame$var[2] <- "liking"
row.names(temp$splits)[2] <- "liking"
temp$splits[1,4] <- 1.849
temp$splits[2,4] <- -0.277
temp$splits[3,4] <- -1.261
#### Figure out all of the fitted means from the CTree object so that they can be pasted in.
#### The point of this is just to be able to plot the CTree using our own plotting function.
mean(covariates$kcal24h0[covariates$hunger <= 1.693])
mean(covariates$kcal24h0[covariates$hunger > 1.693])
mean(covariates$kcal24h0[covariates$hunger <= 1.693 & covariates$liking <= -0.277])
mean(covariates$kcal24h0[covariates$hunger <= 1.693 & covariates$liking > -0.277])
mean(covariates$kcal24h0[covariates$hunger <= 1.693 & covariates$liking > -0.277 & covariates$rrvfood <= -1.261])
mean(covariates$kcal24h0[covariates$hunger <= 1.693 & covariates$liking > -0.277 & covariates$rrvfood > -1.261])
temp$frame$yval<- c(0, -0.09118071,-0.43876,0.1414685,-0.5060532,0.234805,1.38073645)
##### NOTE TO SELF::: TO MAKE THE TREE-PLOTS SQUATTER IN THE PAPER, I MANUALLY CROPPED THE BRANCH LINES SHORTER IN PREVIEW
n <- NROW(blsdata)
nT <- length(unique(p4$where))
SSE <- sqrt(1/(n-nT)*sum((covariates$kcal24h0 - predict(p4))^2))
#sd(blsdata$kcal24h0)
treeval.plot(p4, sigma_y = SSE, inferenceType=4,alpha=0.05, digits=2, printn = FALSE, nn=FALSE)
ggsave()
ggsave(filename="cheese")
?png
png(filename = "~/Dropbox/Tree Values Paper/JMLR Reviewer Responses/bls_tree_SSE.png", width=3, height=5,
units="in")
png(filename = "~/Dropbox/Tree Values Paper/JMLR Reviewer Responses/bls_tree_SSE.png", width=3, height=5,
units="in", res=400)
treeval.plot(p4, sigma_y = SSE, inferenceType=4,alpha=0.05, digits=2, printn = FALSE, nn=FALSE)
dev.off()
p4$frame
png(filename = "~/Dropbox/Tree Values Paper/JMLR Reviewer Responses/bls_tree_cons.png", width=3, height=5,
units="in", res=400)
treeval.plot(p4,inferenceType=4,alpha=0.05, digits=2, printn = FALSE, nn=FALSE)
dev.off()
library(tidyverse)
library(gridExtra)
naivezcol <- "#7CAE00"
sampsplitcol <- "#00BFC4"
treevalcol <- "#F8766D"
setwd("~/Dropbox/Tree Values Paper/Code Reviewer Response/non normal/")
nullResPoisson <- read.csv("poisson.csv", sep=" ", header=FALSE)
nullResGamma <- read.csv("gamma.csv", sep=" ", header=FALSE)
nullResBernoulli <- read.csv("bernoulli.csv", sep=" ", header=FALSE)
nullResCauchy <- read.csv("cauchy.csv", sep=" ", header=FALSE)
nullResMix <- read.csv("mixture.csv", sep=" ", header=FALSE)
nullResBernSmall <- read.csv("bernoulli01.csv", sep=" ", header=FALSE)
dat <- rbind(
cbind(nullResPoisson, "dist"="Poisson(10)"),
cbind(nullResGamma, "dist"= "Gamma(1,10)"),
cbind(nullResBernoulli, "dist"="Bernoulli(0.5)"),
cbind(nullResCauchy, "dist" = "Cauchy(0,1)"),
cbind(nullResMix, "dist" = "Mixture"),
cbind(nullResBernSmall, "dist" = "Bernoulli(0.1)")
)
names(dat) <- c("cp", "seed", "method", "type", "depth", "pval", "n1", "n2", "sampsig", "NA", "dist")
dat$method[dat$method=="splitting"] = "Sample Splitting"
dat$method[dat$method=="NaiveZ"] = "Naive Z-test"
dat$method[dat$method=="Tree-Values"] = "Selective Z-test"
dat$method <- ordered(dat$method, levels=c("Naive Z-test", "Sample Splitting", "Selective Z-test"))
dat$dist <- ordered(dat$dist, levels=c("Poisson(10)", "Bernoulli(0.5)", "Gamma(1,10)","Cauchy(0,1)",
"Miture", "Bernoulli(0.1)"))
ggplot(data=dat %>% filter(dist != "Mixture",
dist != "Cauchy(0,1)"), aes(sample=pval, col=method))+geom_qq(distribution="qunif")+
facet_wrap(vars(dist))+coord_fixed()+theme_bw()+
geom_abline(slope=1,intercept=0)+
labs(col="Method")+
scale_color_manual(values = c(naivezcol, sampsplitcol, treevalcol))+
xlab("Unif(0,1) Quantiles")+ylab("Empirical Quantiles")
ggsave("~/Dropbox/Tree Values Paper/JMLR Reviewer Responses/non_normal.png")
ggsave("~/Dropbox/Tree Values Paper/JMLR_submit_v3/Figures/non_normal.png")
